/* eslint-disable arrow-body-style */
module.exports = {
  up: (queryInterface, Sequelize) => {
    return queryInterface.bulkInsert("Posts", [
      // {
      //   id: 1,
      //   UserId: 1,
      //   title: "My portfolio",
      //   sample: "Get to see what i used to build my portfolio",
      //   image:
      //     "https://images.unsplash.com/photo-1596703720229-1f8fbb8daae5?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1934&q=80",
      //   body: "Welcome back again to my portfolio, I am glad to have you here!",
      //   CategoryId: 2,
      //   createdAt: new Date(),
      //   updatedAt: new Date(),
      // },
      {
        id: 2,
        UserId: "eb939fc1-99e8-4943-bc0d-8c3b3433d2cb",
        title: "Information and Technology",
        sample:
          "Get to know basically what is involved in this field of Information and technology.",
        image:
          "https://images.unsplash.com/photo-1518770660439-4636190af475?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1050&q=80",
        CategoryId: 1,
        body: '<p><span style="font-weight: 400;">According to wikipedia </span><strong>Information technology</strong><span style="font-weight: 400;"> (</span><strong>IT</strong><span style="font-weight: 400;">) is the use of </span><a href="https://en.wikipedia.org/wiki/Computer"><span style="font-weight: 400;">computers</span></a><span style="font-weight: 400;"> to store, retrieve, transmit, and manipulate </span><a href="https://en.wikipedia.org/wiki/Data_(computing)"><span style="font-weight: 400;">data</span></a><a href="https://en.wikipedia.org/wiki/Information_technology#cite_note-DOP-1"><span style="font-weight: 400;">[1]</span></a><span style="font-weight: 400;"> or </span><a href="https://en.wikipedia.org/wiki/Information"><span style="font-weight: 400;">information</span></a><span style="font-weight: 400;">. IT is typically used within the context of </span><a href="https://en.wikipedia.org/wiki/Business_operations"><span style="font-weight: 400;">business operations</span></a><span style="font-weight: 400;"> as opposed to personal or entertainment technologies.</span></p> <p>&nbsp;</p> <p><span style="font-weight: 400;">Basically IT in simple words is a field that contains my computer knowledge and understanding including network , softwares and many more in general.</span></p> <p><br /><br /></p> <h2><strong>THE PROS AND CONS OF INFORMATION AND TECHNOLOGY.</strong></h2> <p>&nbsp;</p> <p><span style="font-weight: 400;">In universities IT is considered as a group of computer based majors and that involves;</span></p> <p><strong>Software engineering</strong><span style="font-weight: 400;"> which is the making of computer software programmes in simple words,</span></p> <p><span style="font-weight: 400;">The next major in IT is </span><strong>Networking </strong><span style="font-weight: 400;">which is the interaction with networks and setting up things like LAN,WAN and basically things that make the connectivity to the internet works, Digging deep into IT majors also involves communication and network systems , Computer data scientists and many more&hellip;</span></p> <p>&nbsp;</p> <h3><strong>THE PROS.</strong></h3> <h3><strong>&nbsp;</strong><strong>&nbsp;&nbsp;&nbsp; </strong><strong>Be better at your job</strong><span style="font-weight: 400;">, For anyone who already has a job or a career in a particular area, IT courses can be an outstanding way to get a greater understanding of the technological aspects of the job. A diploma in IT is highly valued in many careers, especially those with a financial or creative focus. Employees who complete a course in computer science, or similar areas, give themselves a boost on their job performance instantly.</span></h3> <p><strong>&nbsp;Earn more money</strong><span style="font-weight: 400;">, Having a solid base in a practical area, or upskilling if you already have a set of expertise, is the right way to go about starting on a good salary and receiving a raise. As information technology courses are highly prized in modern businesses, graduates get a leg up on the competition with these transferable skills.</span></p> <p><strong>Make more connections</strong><span style="font-weight: 400;">, One of the biggest benefits of completing IT courses that focus on practical skills and employability, is that students meet like-minded classmates and make new connections. Networking is a crucial part of finding employment in the professional sphere, and interacting with others in a learning space will provide insight and friendships that would not be possible otherwise.</span></p> <p><strong>Expand your knowledge </strong><span style="font-weight: 400;">, On a more abstract level, keeping the mind active will have noticeable benefits for anyone who has been out of schooling for a while. By putting themselves in unfamiliar situations and completing new learning challenges, students of these information technology courses often find a renewed enthusiasm for education, as well as a heightened ability to adapt and expand their minds to fresh skill sets.</span></p> <p><strong>Modernize your skills</strong><span style="font-weight: 400;">, Staying relevant in a constantly changing workforce is no easy task, and IT courses are currently among the most consistently expanding areas of demand for employees. Updating a current skill set, or adding extra accomplishments to an existing list, is a sure-fire way to establish mastery and experience in many aspects of your business.</span></p> <h3><strong>THE CONS</strong></h3> <p><strong>Unemployment and lack of job security, </strong><span style="font-weight: 400;">implementing the information systems can save a great deal of time during the completion of tasks and some labor mechanic works. Most paperwork can be processed immediately, financial transactions are automatically calculated, etc. As technology improves, tasks that were formerly performed by human employees are now carried out by computer systems. For example, automated telephone answering systems have replaced live receptionists in many organizations or online and personal assistants can be good examples also. Industry experts believe that the internet has made job security a big issue as technology keeps on changing with each day. This means that one has to be in a constant learning mode, if he or she wishes for their job to be secure.</span></p> <p><strong>Dominant culture,&nbsp; </strong><span style="font-weight: 400;">while information technology may have made the world a global village, it has also contributed to one culture dominating another weaker one. For example it is now argued that the US influences how most young teenagers all over the world now act, dress and behave. Languages too have become overshadowed, with English becoming the primary mode of communication for business and everything else.</span></p> <p><strong>Security issues</strong><span style="font-weight: 400;">, thieves and hackers get access to identities and corporate saboteurs target sensitive company data. Such data can include vendor information, bank records, intellectual property and personal data on company management. The hackers distribute the information over the Internet, sell it to rival companies or use it to damage the company&rsquo;s image. For example, several retail chains were targeted recently by hackers who stole customer information from their information systems and distributed Social Security numbers and credit card data over the Internet.</span></p> <p><strong>Implementation expenses</strong><span style="font-weight: 400;">, to integrate the information system it requires a pretty good amount of cost in the case of software, hardware and people. Software, hardware and some other services should be rented, bought and supported. Employees need to be trained with unfamiliar information technology and software.</span></p> <p>&nbsp;</p> <p>&nbsp;</p> <p><strong>In conclusion</strong><span style="font-weight: 400;">, despite the cons of IT (information and communication Technology) , In general IT is among the best opportunities to major into due to its high increasing rate in employment which can be good for someone`s future.</span></p> <p>&nbsp;</p> <p><span style="font-weight: 400;">KBM.</span></p>',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 3,
        UserId: "eb939fc1-99e8-4943-bc0d-8c3b3433d2cb",
        title: "Debugging",
        sample: "The detailed concepts that gets you started on how to debug.",
        image:
          "https://images.unsplash.com/photo-1511954766786-1f88f53fb528?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=2020&q=80",
        CategoryId: 1,
        body: `<p><strong>Definition</strong><span style="font-weight: 400;">: </span><strong>Debugging</strong><span style="font-weight: 400;"> is the process of detecting and removing existing and potential errors (also called 'bugs') in a software </span><strong>code</strong><span style="font-weight: 400;"> that can cause it to behave unexpectedly or crash.</span></p> <p><span style="font-weight: 400;">In the career of software development you are likely to face bugs as explained in the definition of debugging and in this article i am going to walk you through all kinds of programming bugs and tools and techniques used to solve those kinds of programming bugs.</span></p> <h3><span style="font-weight: 400;">&nbsp;</span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><strong>Types of Bugs</strong></h3> <h2><strong>1. Syntax Errors.</strong></h2> <p><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">J</span><span style="font-weight: 400;">ust like human languages, computer languages have grammar rules. But while humans are able to communicate with less-than-perfect grammar, computers can&rsquo;t ignore mistakes, i.e. syntax errors.</span></p> <p><span style="font-weight: 400;">For example, let&rsquo;s say the correct syntax for printing something is </span><span style="font-weight: 400;">console.log(&lsquo;Hello my name is Bruno&rsquo;)</span><span style="font-weight: 400;">, and we accidentally forget one of the parentheses while coding. A syntax error will happen, and this will stop the program from running.</span></p> <p><span style="font-weight: 400;">As your proficiency with programming language increases, you will make syntax errors less frequently. The easiest way to prevent them from causing you problems is to be aware of them early. Many text editors or IDEs will come with the ability to warn you about syntax errors at the time of writing.</span></p> <h2><strong>2. Logic Errors.</strong></h2> <p><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">Logic errors can be the hardest to track down. Everything looks like it is working; you have just programmed the computer to do the wrong thing. Technically the program is correct, but the results won&rsquo;t be what you expected.</span></p> <p><span style="font-weight: 400;">If you didn&rsquo;t check the requirements beforehand and wrote code to return the oldest user in your system when you needed the newest, you would have a logic error.</span></p> <p><a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure"><span style="font-weight: 400;">A famous example</span></a><span style="font-weight: 400;"> happened in 1999 when NASA lost a spacecraft due to miscalculations between English and American units. The software was coded one way but needed to work another.</span></p> <p><span style="font-weight: 400;">When writing your tests, show them to the product manager or product owner to confirm that the logic you&rsquo;re about to write is correct. In the example above, someone closer to the business would have spotted that you aren&rsquo;t mentioning the fact it is the newest user that is required.</span></p> <h2><strong>3. Compilation Errors.</strong></h2> <p><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">Some programming languages require a compilation step. Compilation is where your high-level language converts into a lower-level language that the computer can understand better. A compilation or compile-time error happens when the compiler doesn&rsquo;t know how to turn your code into the lower-level code.</span></p> <p><span style="font-weight: 400;">In our syntax error example, if we were compiling </span><span style="font-weight: 400;">print('hello'</span><span style="font-weight: 400;">, the compiler would stop and tell us it doesn&rsquo;t know how to convert this into a lower-level language because it expected a </span><span style="font-weight: 400;">)</span><span style="font-weight: 400;"> after the </span><span style="font-weight: 400;">'</span><span style="font-weight: 400;">.</span></p> <p><span style="font-weight: 400;">If there is a compile-time error in your software, you won&rsquo;t be able to get it tested or launched.</span></p> <p><span style="font-weight: 400;">Like syntax errors, you will get better at avoiding these with time, but in general, the best thing you can do is get early feedback when it happens.</span></p> <p><span style="font-weight: 400;">Compilation happens across all files of your project at the same time. If you&rsquo;ve made lots of changes and see lots of compiler warnings or errors, it can be very daunting. By running the compiler often, you will get the feedback you need sooner, and you will more easily know where to address the issues.</span></p> <p><span style="font-weight: 400;">These are the main bugs that most programmers meet, Other bugs include </span><strong>Runtime</strong><strong>, </strong><strong>Arithmetic</strong><strong>, </strong><strong>resource,interface</strong><span style="font-weight: 400;"> errors/bugs.</span></p> <p>&nbsp;</p> <h2><strong>Process to help you debug such errors or bugs mentioned above.</strong></h2> <p>&nbsp;</p> <p><span style="font-weight: 400;">The debugging process usually consists of the following: examine the error symptoms, identify the cause, and finally fix the error. This process may be quite difficult and require a large amount of work, because of the following reasons:&nbsp;</span></p> <ul> <li style="font-weight: 400;" aria-level="1"><strong><em>The symptoms may not give clear indications about the cause</em></strong><em><span style="font-weight: 400;">.</span></em><span style="font-weight: 400;"> In particular, the cause and the symptom may be remote, either in space (i.e., in the program code), or in time (i.e., during the execution of the program), or both. Defensive programming can help reduce the distance between the cause and the effect of an error.</span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong><em>Symptoms may be difficult to reproduce.</em></strong><span style="font-weight: 400;"> Replay is needed to better understand the problem. Being able to reproduce the same program execution is a standard obstacle in debugging concurrent programs. An error may show up only in one particular interleaving of statements from the parallel threads, and it may be almost impossible to reproduce that same, exact interleaving. </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong><em>Errors may be correlated</em></strong><em><span style="font-weight: 400;">.</span></em><span style="font-weight: 400;"> Therefore, symptoms may change during debugging, after fixing some of the errors. The new symptoms need to be re-examined. The good part is that the same error may have multiple symptoms; in that case, fixing the error will eliminate all of them. </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong><em>Fixing an error may introduce new errors</em></strong><em><span style="font-weight: 400;">. </span></em><span style="font-weight: 400;">Statistics indicate that in many cases fixing a bug introduces a new one! This is the result of trying to do quick hacks to fix the error, without understanding the overall design and the invariants that the program is supposed to maintain. Once again, a clean design and careful thinking can avoid many of these cases.</span></li> </ul> <p>&nbsp;</p> <h2><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span><strong>DEBUGGING STRATEGIES</strong></h2> <p>&nbsp;</p> <p><span style="font-weight: 400;">Although there is no precise procedure for fixing all bugs, there are a number of useful strategies that can reduce the debugging effort. A significant part (if not all) of this process is spent localizing the error, that is, figuring out the cause from its symptoms. Below are several useful strategies to help with this. Keep in mind that different techniques are better suited in different cases; there is no clear best method. It is good to have knowledge and experience with all of these approaches. Sometimes, a combination of one or more of these approaches will lead you to the error.&nbsp;</span></p> <ul> <li style="font-weight: 400;" aria-level="1"><strong>Incremental and bottom-up program development.</strong><span style="font-weight: 400;"> One of the most effective ways to localize errors is to develop the program incrementally, and test it often, after adding each piece of code. It is highly likely that if there is an error, it occurs in the last piece of code that you wrote. With incremental program development, the last portion of code is small; the search for bugs is therefore limited to small code fragments. An added benefit is that small code increments will likely lead to few errors, so the programmer is not overwhelmed with long lists of errors. </span><span style="font-weight: 400;"><br /></span> <span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">Bottom-up development maximizes the benefits of incremental development. With bottom-up development, once a piece of code has been successfully tested, its behavior won't change when more code is incrementally added later. Existing code doesn't rely on the new parts being added, so if an error occurs, it must be in the newly added code (unless the old parts weren't tested well enough).</span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Instrument program to log information.</strong><span style="font-weight: 400;"> Typically, print statements are inserted. Although the printed information is effective in some cases, it can also become difficult to inspect when the volume of logged information becomes huge. In those cases, automated scripts may be needed to sift through the data and report the relevant parts in a more compact format. Visualization tools can also help understand the printed data. For instance, to debug a program that manipulates graphs, it may be useful to use a graph visualization tool (such as ATT's </span><a href="http://www.graphviz.org/"><strong>graphviz</strong></a><span style="font-weight: 400;">) and print information in the appropriate format (.dot files for graphviz). </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Instrument program with assertions.</strong><span style="font-weight: 400;"> Assertions check if the program indeed maintains the properties or invariants that your code relies on. Because the program stops as soon as an assertion fails, it's likely that the point where the program stops is much closer to the cause, and is a good indicator of what the problem is. An example of assertion checking is the repOK() function that verifies if the representation invariant holds at function boundaries. Note that checking invariants or conditions is the basis of defensive programming. The difference is that the number of checks is usually increased during debugging for those parts of the program that are suspected to contain errors. </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Use debuggers. </strong><span style="font-weight: 400;">If a debugger is available, it can replace the manual instrumentation using console.logs if using javascript statements or assertions. Setting breakpoints in the program, stepping into and over functions, watching program expressions, and inspecting the memory contents at selected points during the execution will give all&nbsp; the needed run-time information without generating large, hard-to-read log files.</span></li> </ul> <p><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></p> <ul> <li style="font-weight: 400;" aria-level="1"><strong>Backtracking.</strong><span style="font-weight: 400;"> One option is to start from the point where the problem occurred and go back through the code to see how that might have happened. </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Binary search.</strong><span style="font-weight: 400;"> The backtracking approach will fail if the error is far from the symptom. A better approach is to explore the code using a divide-and-conquer approach, to quickly pin down the bug. For example, starting from a large piece of code, place a check halfway through the code. If the error doesn't show up at that point, it means the bug occurs in the second half; otherwise, it is in the first half. Thus, the code that needs inspection has been reduced to half. Repeating the process a few times will quickly lead to the actual problem. </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Problem simplification.</strong><span style="font-weight: 400;"> A similar approach is to gradually eliminate portions of the code that are not relevant to the bug. For instance, if a function fun f() = (g();h();k()) yields an error, try eliminating the calls to g, h, and k successively (by commenting them out), to determine which is the erroneous one. Then simplify the code in the body of the buggy function, and so on. Continuing this process, the code gets simpler and simpler. The bug will eventually become evident. A similar technique can be applied to simplify data rather than code. If the size of the input data is too large, repeatedly cut parts of it and check if the bug is still present. When the data set is small enough, the cause may be easier to understand.</span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>A scientific method: form hypotheses.</strong><span style="font-weight: 400;"> A related approach is as follows: inspect the test case results; form a hypothesis that is consistent with the observed data; and then design and run a simple test to refute the hypothesis. If the hypothesis has been refuted, derive another hypothesis and continue the process. In some sense, this is also a simplification process: it reduces the number of possible hypotheses at each step. But unlike the above simplification techniques, which are mostly mechanical, this process is driven by active thinking about an explanation. A good approach is to try to come with the simplest hypotheses and the simplest corresponding test cases. </span><span style="font-weight: 400;"><br /></span> <span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">Consider, for example, a function palindrome(s:string):bool, and suppose that palindrome("able was I were I saw elba") returns an incorrect value of false. Here are several possible hypotheses for this failure. Maybe palindrome fails for inputs with spaces (test " "); maybe it fails for programs with upper case letters (try "I"); maybe it fails for inputs of odd length greater than one (try "ere"), and so on.&nbsp; Forming and testing these hypotheses one after another can lead the programmer to the source of the problem.</span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Bug clustering.</strong><span style="font-weight: 400;"> If a large number of errors are being reported, it is useful to group them into classes of related bugs (or similar bugs), and examine only one bug from each class. The intuition is that bugs from each class have the same cause (or a similar cause). Therefore, fixing a bug will automatically fix all the other bugs from the same class (or will make it obvious how to fix them).</span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;">&nbsp;</span></li> <li style="font-weight: 400;" aria-level="1"><strong>Error-detection tools. </strong><span style="font-weight: 400;">Such tools can help programmers quickly identify violations of certain classes of errors. For instance, tools that check safety properties can verify that file accesses in a program obey the open-read/write-close file sequence; that the code correctly manipulates locks; or that the program always accesses valid memory. Such tools are either dynamic (they instrument the program to find errors at run-time), or use static analysis (look for errors at compile-time). For instance, </span><a href="http://www-306.ibm.com/software/awdtools/purifyplus"><strong>Purify</strong></a><span style="font-weight: 400;"> is a popular dynamic tool that instruments programs to identify memory errors, such as invalid accesses or memory leaks. Examples when using javascript and VScode as your IDE. i would suggest vs code extension as</span> <strong>ESlint</strong><span style="font-weight: 400;"> which will help you find errors and Bugs without even realising it.</span></li> </ul> <p><span style="font-weight: 400;">&nbsp;&nbsp;&nbsp; </span></p> <p><span style="font-weight: 400;">Eslint is going to help you realise the error within a statement most especially syntax errors and Typos, as shown below;</span></p> <p><br /><br /><br /></p> <h2><strong>BEST PRACTICES TO AVOID FUTURE BUGS.</strong></h2> <p><br /><br /></p> <p><strong>Leverage the Hints from the IDE</strong></p> <p><span style="font-weight: 400;">This one should be obvious to most programmers, but the reality is that the tools we use are a bit smarter than what we give them credit for. It&rsquo;s easy to miss these hints. They are sometimes buried in build logs, drowned in a sea of flags, visually too subtle to attract our much-needed attention. Listen to your Integrated Development Environment (IDE)&mdash;it is telling you something.</span></p> <p><span style="font-weight: 400;">One of the most obvious signs that something is up with your code is when the IDE tells you that you are not using a variable you introduced earlier in your code. You had some intent for this variable, but that intent got lost while working on some other aspect. There is certainly a bug lurking there.</span></p> <p><span style="font-weight: 400;">Another useful alert is when the IDE detects that there is a logical path for a </span><em><span style="font-weight: 400;">NullPointerException</span></em><span style="font-weight: 400;">. Maybe the most common case is well taken care of, but there seems to be a road less-travelled to this ubiquitous exception.</span></p> <p><span style="font-weight: 400;">The activity of writing code forces you to concentrate on the text you are typing while keeping a stack of other concerns in mind. This cognitive load is already heavy; I like to reduce it by removing ambiguities. The IDE will tell you when you are using the same variable name for an instance variable and a local variable. I don&rsquo;t need to risk being confused about which one I am manipulating. I&rsquo;ll follow my digital assistant&rsquo;s advice and rename the local variable in question.</span></p> <p><strong>Break up Your Content</strong></p> <p><span style="font-weight: 400;">The brain can only keep so much information. And each coding window only shows you about 50 lines. When the code grows, so does the likelihood of bugs, just from not remembering details implemented a few invisible lines away. One simple technique to avoid such troubles is to break up the code. Keep the methods short. Ideally, a well-focused class shouldn&rsquo;t have more than 200 lines. It&rsquo;s not always possible, but where it is, you can avoid bugs when each class has only one responsibility. The class&rsquo; code itself is easy to review, and its function is easy to remember in other contexts. If you just wrote a large body of code in one class, it&rsquo;s time to break it up into smaller pieces.</span></p> <p><span style="font-weight: 400;">This is nothing new. When the metric of cyclomatic complexity was developed in 1976, its first applications tried to limit the complexity of each module, splitting them into smaller modules. These modules became easier to write, and easier to test, too. If the most likely place for defects is where complexity lies, reducing complexity automatically reduces the rate of defects.</span></p> <p><span style="font-weight: 400;">It&rsquo;s not just the height of your screen that matters when having &ldquo;too much to code&rdquo; might be &ldquo;too much to cope.&rdquo; The width matters, too. This is actually a classic source of </span><span style="font-weight: 400;">bugs: a line goes beyond what&rsquo;s visible without scrolling, meaning it&rsquo;s not being looked at as often as </span><span style="font-weight: 400;">other lines. Code reviewed less is more likely to be incorrect. Long lines are also bug candidates when overly confident IDEs autofill their content over the developer&rsquo;s watchful eyes. The simple solution is to break up these long lines, for example, inserting carriage returns when they go over 120 characters. The IDE will often show you this limit graphically.</span></p> <p>&nbsp;</p> <p><strong>Don&rsquo;t Leave Your Code to Chance.</strong></p> <p><span style="font-weight: 400;">I have seen many cases where two (or more) classes have the exact same name. They have different package names, but package names are hidden away at the very beginning of each class that uses another class. It&rsquo;s a good idea to give classes unique names across your code base. This will make sure there is no ambiguity around which one a developer is using. Murphy&rsquo;s law is not your friend&mdash;you will inevitably pick the wrong one otherwise.</span></p> <p><span style="font-weight: 400;">The behavior of </span><em><span style="font-weight: 400;">HashMaps</span></em><span style="font-weight: 400;"> may also be a source of hard-to-troubleshoot bugs. The Java Virtual Machine tends to optimize the behavior of </span><em><span style="font-weight: 400;">HashMaps</span></em><span style="font-weight: 400;"> when the application load grows. What this means for developers is that you will observe one behavior during development, and a different behavior in production. To avoid this kind of head-scratching riddle, I have learned to use </span><em><span style="font-weight: 400;">LinkedHashMaps</span></em><span style="font-weight: 400;"> even when not needed as they will always return entries in a consistent manner. This is a trick to use wisely: the performance cost of using </span><em><span style="font-weight: 400;">LinkedHashMaps</span></em><span style="font-weight: 400;"> should be weighed against the risk of having to solve a problem that only happens in production.</span></p> <p><strong>Reuse Existing Code</strong></p> <p><span style="font-weight: 400;">At the end of the day, there is so much to keep track of, just writing code is doomed to produce bugs. The simplest way to avoid writing bugs is not write any code at all, and leverage some other battle-tested component instead.</span></p> <p><span style="font-weight: 400;">Reusing code is the ultimate simplification technique, but I am not just talking about integrating other people&rsquo;s work into your own software. The code you already have is the result of many refactorings. It has real-world experience you are missing (or that you forgot). Use the code you already have as your template. If the quality of your template is not what you need, refactor this code, then reuse it. There shouldn&rsquo;t be in your program &ldquo;two best patterns&rdquo; to do the same thing.</span></p> <p><span style="font-weight: 400;">As I implement a new feature, I typically look at similar code doing similar things: how classes, methods, and variables are (meaningfully) named, which properties and behaviors are exposed, how objects interact with each other, etc. In all the bodies of code I have maintained for several years, I have found that consistency is the easiest constraint to follow, to teach, and the one that brings the most benefits in terms of overall quality.</span></p> <p><br /><br /></p> <p><strong>Code Refactoring.</strong></p> <p><strong>Code refactoring</strong><span style="font-weight: 400;"> is a process used in the DevOps software development approach that involves editing and cleaning up previously written software code without changing the function of the code at all.</span></p> <p>&nbsp;</p> <p><span style="font-weight: 400;">The basic purpose of code refactoring is to make the code more efficient and maintainable. This is key in reducing technical cost since it&rsquo;s much better to clean up the code now than pay for costly errors later. Code refactoring, which improves readability, makes the QA and debugging process go much more smoothly. And while it doesn&rsquo;t remove bugs, it can certainly help prevent them in the future.</span></p> <p><span style="font-weight: 400;">And this is why there is a need for routine code refactoring.</span></p> <p><span style="font-weight: 400;">Code refactoring is important if you want to avoid the dreaded </span><em><span style="font-weight: 400;">code rot</span></em><span style="font-weight: 400;">. Code rot results from duplicate code, myriad patches, bad classifications, and other programming discrepancies. Having a revolving door of different developers writing in their own styles can also contribute to code rot, as there is no cohesion to the overall coding script.</span></p> <p>&nbsp;</p> <h3><strong>Best practices for code refactoring.</strong></h3> <p><br /><br /></p> <p><span style="font-weight: 400;">There are several best practices and recommendations regarding code refactoring. One of the smartest ways to approach it is to apply the Agile method and do it one step at a time, followed by testing. This is why so many developers utilizing Agile methodology are big proponents of code refactoring.</span></p> <p><span style="font-weight: 400;">Breaking down the refactoring process into manageable chunks and performing timely testing before moving on to other updates always results in a higher quality application and a better overall development experience.</span></p> <p><span style="font-weight: 400;">Here are a few other best practices:</span></p> <h3><strong>Refactor first before adding any new features</strong></h3> <p><span style="font-weight: 400;">It is always a good idea to perform refactoring whenever you&rsquo;re asked to add new features or updates to an existing solution. Yes, it will take</span></p> <p><span style="font-weight: 400;">longer to finish the project, but it will also reduce the amount of technical debt you or the product owner will have to deal with in the future.</span></p> <h3><strong>Plan your refactoring project and timeline carefully</strong></h3> <p><span style="font-weight: 400;">One of the hardest parts of code refactoring is finding the time to do it properly.</span></p> <p><span style="font-weight: 400;">Think about your overall goal. Do you just want to change the variable names to improve readability? Or do you want to do a full-on cleanup? What are the best ways for you to optimize the code within a reasonable timeframe?</span></p> <p><span style="font-weight: 400;">The most important outcome of refactoring is that not only is the code cleaner but that it actually works. And remember, it&rsquo;s going to take longer than you think, so plan accordingly and give yourself a little extra cushion of time.</span></p> <h3><strong>Test often</strong></h3> <p><span style="font-weight: 400;">The last thing you want to do when refactoring is mess something up in the process and create bugs or problems that affect the functionality of the product. This is why testing throughout the refactoring process is imperative.</span></p> <p><span style="font-weight: 400;">Make sure you have proper tests in place before starting any refactoring project.</span></p> <h3><strong>Get your QA team involved</strong></h3> <p><span style="font-weight: 400;">It&rsquo;s always a good idea to get your QA and testing team involved in the refactoring process. Whenever you&rsquo;re making changes to existing code, even as a clean-up project, it can affect testing outcomes.</span></p> <p><span style="font-weight: 400;">Changes in classification done during refactoring can cause old tests to fail. In addition, new tests may have to be created for outdated legacy software systems. Both in-depth and regression testing should be performed as part of a refactoring effort. This will ensure that the functionality of the solution was not affected in any way.</span></p> <p><span style="font-weight: 400;">Development teams using the Agile method for both programming and testing will most likely already be on the same page involving refactoring.</span></p> <h3><strong>Focus on progress, not perfection</strong></h3> <p><span style="font-weight: 400;">All code eventually becomes the dreaded legacy code.</span></p> <p><span style="font-weight: 400;">Accept the fact that you will never be 100 percent satisfied. The code you&rsquo;re currently refactoring will become stale and outdated in the near future and will require refactoring all over again.</span></p> <p><span style="font-weight: 400;">You have to start thinking about refactoring as an ongoing maintenance project. Just like you have to clean and organize your home throughout the week, you will need to clean and organize your code on many different occasions.</span></p> <h3><strong>Try refactoring automation</strong></h3> <p><span style="font-weight: 400;">As with most processes, the more it can be automated, the easier and faster refactoring becomes.</span></p> <p><span style="font-weight: 400;">Automating some or all of the refactoring processes is becoming more and more popular with developers. There are many shortcuts and tools to make refactoring less painful. A lot of them can be learned by reading Martin Fowler&rsquo;s book.</span></p> <p><span style="font-weight: 400;">Two IDEs (Integrated Development Environments) that have built-in automated refactoring support are Eclipse and IntelliJ IDEA. Look for more refactoring automation in other IDEs in the near future as refactoring shortcuts continue to be a major concern for the development community.</span></p> <p>&nbsp;</p> <h2><strong>Code Refactoring in Action;</strong></h2> <p><span style="font-weight: 400;">This kind of code can be refactored and be changed to something like this and still produces the same output;</span></p> <p><span style="font-weight: 400;">This will help in reading and understanding your code more easily and also avoid many lines and messy code.</span></p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p><br /><br /><br /><br /></p>`,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 4,
        UserId: "eb939fc1-99e8-4943-bc0d-8c3b3433d2cb",
        title: "My journey through ATLP",
        sample: "This is my Andela Technical Leadership Program walkthrough.",
        image:
          "https://andela.com/wp-content/uploads/2019/08/defaultAndela.png",
        CategoryId: 2,
        body: '<p><span style="font-weight: 400;">ATLP</span> <strong>Andela Technical Leadership program</strong><span style="font-weight: 400;"> is a project hosted by Andela Rwanda to help train motivated software engineers to become job ready and acquire technical skills within a short period of time.&nbsp;</span></p> <p>&nbsp;</p> <h2><span style="font-weight: 400;">WHY I JOINED ANDELA</span></h2> <p><span style="font-weight: 400;">Andela felt like a headstart to my career goals as a software engineer. I needed to find a place where I could put my skills in programming to use and test, and that is when andela came in.</span></p> <p>&nbsp;</p> <p><span style="font-weight: 400;">By joining Andela, a trainee is able to acquire&nbsp; advanced skills and technologies like NODE JS , REACT , MONGODB , PostGres , GITHUB and GIT, You also get to meet your trainers who are not just trainers but also like brothers. Andela is not only a team but also an expanding family.</span></p> <h2><span style="font-weight: 400;">WHAT I&rsquo;M GETTING FROM ANDELA</span></h2> <p><span style="font-weight: 400;">There are many skills that Andela provides, not only working with computers but also interacting with the world and its people. By saying that I mean the world class technical skills taught by the best pals in Andela.</span></p> <p>&nbsp;</p> <p><span style="font-weight: 400;">As a team, we work remotely, Which is also another skill that we must be familiar with because the world is changing so fast. In fact&nbsp; I think people will no longer go to work at the office but rather stay at home and work from there.</span></p> <p>&nbsp;</p> <p><span style="font-weight: 400;">To the part of programming, we get to work with a technology that allows us to share codes and update codes as if we are working in the same room. Github is the technology that we use and thanks to our facilitators&nbsp; that taught us how to interact with it.</span><br /><br /></p> <h2><span style="font-weight: 400;">WHERE I SEE MYSELF IN THE FUTURE</span></h2> <p><span style="font-weight: 400;">After completing the wonderful 9 months with andela, I see myself in a world of programming. Also ready to start fulfilling&nbsp; my dreams of working with tech companies.</span></p> <p><span style="font-weight: 400;">Andela helps us become differentiated from other software engineers around the globe, and how is that!;</span></p> <p><span style="font-weight: 400;">We acquired iconic skills which included working remotely also the technical skills that we acquire which help us to keep a good attitude with our workmates and more about problem solving when working in teams.&nbsp; We&nbsp; also learn&nbsp; public speaking skills that help you to know how to sell your ideas&nbsp; , defend your projects and talk among large numbers.</span></p> <p><span style="font-weight: 400;">This will help me start working with many people on big projects and outstanding everyone else</span></p> <p><span style="font-weight: 400;">on the job market.</span></p> <p><br /><br /></p> <p><strong>All in all</strong><span style="font-weight: 400;"> I would recommend Rwandan programmers out there globally to join Andela as soon as possible. Best regards.</span></p> <p><br /><br /></p> <p><span style="font-weight: 400;">KBM.</span></p>',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ]);
  },

  down: (queryInterface, Sequelize) => {
    return queryInterface.bulkDelete("Posts", null, {});
  },
};
